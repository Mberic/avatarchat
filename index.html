<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AvatarChat</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="app-bar">
        <div class="id-section">
            <label for="pub-stream">Pub Stream: </label>
            <input type="text" id="pub-stream" placeholder="Enter 1 or 2">
        </div>
        <div class="id-section">
            <label for="sub-stream">Sub Stream: </label>
            <input type="text" id="sub-stream" placeholder="Enter 1 or 2">
        </div>
        <button onclick="setStreamIds()">Set Stream IDs</button>        
    </div>
    
    <video id="video" width="640" height="480" autoplay></video>
    <audio id="audio" controls></audio>
    <canvas id="canvas" width="640" height="480"></canvas>

    <script>
        const video = document.getElementById('video');
        const audioElement = document.getElementById('audio');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');

        const apiKey = 'YjVjZmI1MjYzYWY0NDA5MWIyMzMzMjQzODNiYzA1Nzc';
  
        let pub;
        let sub;
        let isWebSocketOpen = false;
        let mediaRecorder;
        let audioChunks = [];

        function setStreamIds() {
            const pubStreamInput = document.getElementById('pub-stream').value;
            const subStreamInput = document.getElementById('sub-stream').value;

            // Ensure pub and sub streams are not the same
            if (pubStreamInput === subStreamInput) {
                alert("Pub Stream and Sub Stream cannot be the same.");
                return;
            }

            if (pubStreamInput !== "1" && pubStreamInput !== "2") {
                alert("Please enter 1 or 2 for Pub Stream");
                return;
            }

            if (subStreamInput !== "1" && subStreamInput !== "2") {
                alert("Please enter 1 or 2 for Sub Stream");
                return;
            }

            const pubStreamId = encodeURIComponent(`0x5dbef432d012c8d20993214f2c3765e9cf83d180/avatarchat-${pubStreamInput}`);
            const subStreamId = encodeURIComponent(`0x5dbef432d012c8d20993214f2c3765e9cf83d180/avatarchat-${subStreamInput}`);

            // Close existing WebSocket connections if open
            if (pub) {
                pub.close();
            }
            if (sub) {
                sub.close();
            }

            // Reconnect WebSockets with the new stream IDs
            pub = new WebSocket(`wss://adjusted-bass-scarcely.ngrok-free.app/streams/${pubStreamId}/publish?apiKey=${apiKey}`);
            sub = new WebSocket(`wss://adjusted-bass-scarcely.ngrok-free.app/streams/${subStreamId}/subscribe?apiKey=${apiKey}`);

            // Set up event handlers for the new WebSocket connections
            pub.onopen = function () {
                console.log('Connected to the WebSocket for sending data.');
                isWebSocketOpen = true;
            };

            pub.onerror = function (err) {
                console.error('WebSocket error (publishing):', err);
            };

            pub.onclose = function () {
                console.log('WebSocket connection closed (publishing).');
                isWebSocketOpen = false;
            };

            sub.onopen = function () {
                console.log('Connected to the WebSocket for receiving data.');
                isWebSocketOpen = true;

                processFrame();
            };

            sub.onerror = function (err) {
                console.error('WebSocket error (subscribing):', err);
            };

            sub.onclose = function () {
                console.log('WebSocket connection closed (subscribing).');
            };

            // Handle incoming messages (video frames and audio)
            sub.onmessage = (event) => {
                // Parse the JSON data
                let parsedData;
                try {
                    parsedData = JSON.parse(event.data);
                } catch (e) {
                    console.error('Error parsing JSON:', e);
                    return;
                }

                // Handle video data
                if (parsedData.video) {
                    const base64Image = parsedData.video;
                    const img = new Image();
                    img.onload = () => {
                        context.drawImage(img, 0, 0, canvas.width, canvas.height);
                    };
                    img.src = 'data:image/png;base64,' + base64Image;
                }

                // Handle audio data
                if (parsedData.audio) {
                    const audioData = parsedData.audio;
                    const audioBlob = new Blob([Uint8Array.from(atob(audioData), c => c.charCodeAt(0))], { type: 'audio/webm' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioElement.src = audioUrl;
                    audioElement.play(); // Use the existing audioElement to play the audio
                }
            };


            console.log('WebSocket connections updated with new stream IDs:', pubStreamId, subStreamId);
        }

        // Access the webcam and microphone
        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
            .then(stream => {
                video.srcObject = stream;

                // Set up the MediaRecorder for capturing audio
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);

                        // Send audio data as base64
Â                         const reader = new FileReader();
                        reader.onload = () => {
                            if (isWebSocketOpen) {
                                pub.send(JSON.stringify({ audio: reader.result.split(',')[1] }));
                            }
                        };
                        reader.readAsDataURL(event.data);
                    }
                };

                mediaRecorder.start(100); // Collect audio data every 100ms
            })
            .catch(err => {
                console.error("Error accessing the camera or microphone: " + err);
            });

        // Sobel edge detection algorithm
        function applySobelFilter(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const gray = new Uint8ClampedArray(width * height);

            // Convert to grayscale
            for (let i = 0; i < gray.length; i++) {
                const r = imageData.data[i * 4];
                const g = imageData.data[i * 4 + 1];
                const b = imageData.data[i * 4 + 2];
                gray[i] = 0.3 * r + 0.59 * g + 0.11 * b;
            }

            // Sobel kernels
            const sobelX = [
                -1, 0, 1,
                -2, 0, 2,
                -1, 0, 1
            ];
            const sobelY = [
                -1, -2, -1,
                0, 0, 0,
                1, 2, 1
            ];

            // Apply Sobel filter
            const output = new Uint8ClampedArray(width * height);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0;
                    let gy = 0;

                    // Convolve with Sobel kernels
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixelVal = gray[(y + ky) * width + (x + kx)];
                            gx += pixelVal * sobelX[(ky + 1) * 3 + (kx + 1)];
                            gy += pixelVal * sobelY[(ky + 1) * 3 + (kx + 1)];
                        }
                    }

                    // Compute gradient magnitude
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    output[y * width + x] = magnitude > 128 ? 255 : 0; // Edge threshold
                }
            }

            // Set edge data to imageData
            for (let i = 0; i < output.length; i++) {
                const value = output[i];
                imageData.data[i * 4] = value > 0 ? 139 : 0;    // Red
                imageData.data[i * 4 + 1] = value > 0 ? 117 : 0; // Green
                imageData.data[i * 4 + 2] = 0;                  // Blue
                imageData.data[i * 4 + 3] = 255;                // Full opacity

            }
        }

        // Draw the video frame to the canvas, apply edge detection, and send to WebSocket
        function processFrame() {
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = context.getImageData(0, 0, canvas.width, canvas.height);
            applySobelFilter(frame);
            context.putImageData(frame, 0, 0);

            // Convert the processed frame to a base64 string
            const base64Image = canvas.toDataURL('image/png').split(',')[1];

            // Send the base64 string to the WebSocket server
            if (isWebSocketOpen) {
                pub.send(JSON.stringify({ video: base64Image }));
            } else {
                console.error('WebSocket is not open. Cannot send data.');
            }

            requestAnimationFrame(processFrame);
        }

        // Start processing when the video starts playing
        // video.addEventListener('play', () => {
        //     processFrame();
        // });
    </script>
</body>
</html>
